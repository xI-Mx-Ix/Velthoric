import net.fabricmc.loom.task.RemapJarTask

plugins {
    id 'dev.architectury.loom' version '1.13-SNAPSHOT' apply false
    id 'architectury-plugin' version '3.4-SNAPSHOT'
    id 'com.gradleup.shadow' version '8.3.6' apply false
    id 'net.xmx.velthoric.publishing'
}

architectury {
    minecraft = project.minecraft_version
}

allprojects {
    group = rootProject.maven_group
    version = rootProject.mod_version
}

subprojects {
    apply plugin: 'dev.architectury.loom'
    apply plugin: 'architectury-plugin'
    apply plugin: 'maven-publish'

    // Apply the publishing plugin to subprojects to expose the 'velthoricPublishing' extension
    apply plugin: 'net.xmx.velthoric.publishing'

    def archiveMap = [
            "fabric"    : "velthoric-fabric",
            "forge"     : "velthoric-forge",
            "neoforge"  : "velthoric-neoforge",
            "common"    : "velthoric-common",
            "vx-events" : "vx-events",
            "vx-native" : "vx-native"
    ]

    base {
        archivesName = archiveMap.getOrDefault(project.name, "$rootProject.archives_name-$project.name")
    }

    repositories {
        mavenCentral()
        maven { url = 'https://cursemaven.com'}
        maven { url = 'https://maven.parchmentmc.org' }
        maven { url = 'https://jitpack.io' }
        maven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots'}

        flatDir {
            dirs rootProject.file('libraries')
        }
    }

    tasks.withType(RemapJarTask).configureEach {
        if (project.name == 'common' || project.name == 'vx-events' || project.name == 'vx-native') {
            addNestedDependencies = false
        }
    }

    loom {
        silentMojangMappingsLicense()

        mixin {
            useLegacyMixinAp = true
        }

        def refmaps = [
                'vx-events': 'vx-events-refmap.json',
                'common'   : 'velthoric-refmap.json'
        ]

        refmaps.each { proj, refmap ->
            if (project.name == proj) {
                mixin.defaultRefmapName.set(refmap)
            }
        }
    }

    dependencies {
        minecraft "net.minecraft:minecraft:$rootProject.minecraft_version"

        mappings loom.layered {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${minecraft_version}:${parchment_version}@zip")
        }
    }

    java {
        withSourcesJar()

        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.release = 21
    }

    tasks.withType(GenerateModuleMetadata).configureEach {
        enabled = false
    }
}

task generateJoltDoc {

    def joltModule = configurations.detachedConfiguration(
            dependencies.create("com.github.stephengold:jolt-jni-Linux64:${jolt_jni_version}")
    ).singleFile

    def outputFile = file("$buildDir/docs/jolt.txt")

    inputs.file(joltModule)
    outputs.file(outputFile)

    doLast {
        println "=== JoltDoc Generation Started ==="

        if (!joltModule.exists()) {
            throw new FileNotFoundException("Input JAR not found: ${joltModule.absolutePath}")
        }

        println "Analyzing JAR: ${joltModule.name}"
        println "Writing output to: ${outputFile.absolutePath}"

        outputFile.parentFile.mkdirs()
        outputFile.text = ''

        def zipFile = new java.util.zip.ZipFile(joltModule)
        def classEntries = zipFile.entries().findAll { entry ->
            !entry.isDirectory() && entry.name.endsWith('.class')
        }

        println "Found ${classEntries.size()} class files."

        classEntries.eachWithIndex { entry, idx ->
            def className = entry.name.replace('/', '.').replaceAll('\\.class$', '')
            println "[${idx + 1}/${classEntries.size()}] Processing class: ${className}"

            def commandOutput = new ByteArrayOutputStream()

            project.exec {
                executable = 'javap'
                args '-p', '-classpath', joltModule.absolutePath, className
                standardOutput = commandOutput
                ignoreExitValue = true
            }

            outputFile.append("${className.substring(className.lastIndexOf('.') + 1)}.class:\n")

            def javapResult = commandOutput.toString()
            def methodLines = javapResult.lines()
                    .findAll { it.contains('(') && it.contains(')') && !it.contains('{') && !it.contains('Compiled from') }
                    .findAll { it.trim().startsWith('public') || it.trim().startsWith('protected') }

            println "  Found ${methodLines.size()} methods in ${className}."

            methodLines.each { line ->
                String cleanedLine = line.trim()
                        .replaceAll('public |protected |static |final |synchronized |native ', '')

                if (line.trim().startsWith('protected')) {
                    cleanedLine = "protected ${cleanedLine}"
                }

                outputFile.append("  ${cleanedLine}\n")
                println "    Logged method: ${cleanedLine}"
            }

            outputFile.append("\n")
        }

        zipFile.close()
        println "=== JoltDoc Generation Finished ==="
    }
}