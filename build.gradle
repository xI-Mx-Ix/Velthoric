import net.fabricmc.loom.task.RemapJarTask

plugins {
    id 'dev.architectury.loom' version '1.10-SNAPSHOT' apply false
    id 'architectury-plugin' version '3.4-SNAPSHOT'
    id 'com.gradleup.shadow' version '8.3.6' apply false

    id "me.modmuss50.mod-publish-plugin" version "0.8.4" apply false
    id "com.github.breadmoirai.github-release" version "2.4.1" apply false
}

architectury {
    minecraft = project.minecraft_version
}

allprojects {
    group = rootProject.maven_group
    version = rootProject.mod_version
}

/**
 * Credential Loading Logic.
 * Loads sensitive data from 'credentials.properties' if available.
 * Assigns values to project-wide extension properties.
 */
def credentialsFile = file('credentials.properties')
if (credentialsFile.exists()) {
    def properties = new Properties()
    credentialsFile.withInputStream { properties.load(it) }
    ext.modrinth_token = properties.getProperty('modrinth_token')
    ext.curseforge_token = properties.getProperty('curseforge_token')
    ext.cloudsmith_user = properties.getProperty('cloudsmith_user')
    ext.cloudsmith_key = properties.getProperty('cloudsmith_key')
    ext.github_token = properties.getProperty('github_token')
} else {
    ext.modrinth_token = null
    ext.curseforge_token = null
    ext.cloudsmith_user = null
    ext.cloudsmith_key = null
    ext.github_token = null
}

/**
 * Resolves the changelog for the current version.
 * @return The content of the changelog markdown file.
 */
def resolveChangelog() {
    def currentVersionFile = rootProject.file("changelog/${rootProject.mod_version}.md")
    if (currentVersionFile.exists()) {
        return currentVersionFile.text
    }

    if (rootProject.mod_version.endsWith("-SNAPSHOT")) {
        def releaseVersion = rootProject.mod_version.replace("-SNAPSHOT", "")
        def releaseVersionFile = rootProject.file("changelog/${releaseVersion}.md")
        if (releaseVersionFile.exists()) {
            return releaseVersionFile.text
        }
    }

    return "No changelog provided for this version."
}

// Apply the external publishing logic script
apply from: 'publish.gradle'

subprojects {
    apply plugin: 'dev.architectury.loom'
    apply plugin: 'architectury-plugin'
    apply plugin: 'maven-publish'

    def archiveMap = [
            "fabric"    : "velthoric-fabric",
            "forge"     : "velthoric-forge",
            "neoforge"  : "velthoric-neoforge",
            "common"    : "velthoric-common",
            "vx-events" : "vx-events",
            "vx-native" : "vx-native"
    ]

    base {
        archivesName = archiveMap.getOrDefault(project.name, "$rootProject.archives_name-$project.name")
    }

    repositories {
        mavenCentral()
        maven { url = 'https://cursemaven.com'}
        maven { url = 'https://maven.parchmentmc.org' }
        maven { url = 'https://jitpack.io' }
        maven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots'}

        flatDir {
            dirs rootProject.file('libraries')
        }
    }

    tasks.withType(RemapJarTask).configureEach {
        if (project.name == 'common' || project.name == 'vx-events' || project.name == 'vx-native') {
            addNestedDependencies = false
        }
    }

    loom {
        silentMojangMappingsLicense()

        def refmaps = [
                'vx-events': 'vx-events-refmap.json',
                'common'   : 'velthoric-refmap.json'
        ]

        refmaps.each { proj, refmap ->
            if (project.name == proj) {
                mixin.defaultRefmapName.set(refmap)
            }
        }
    }

    dependencies {
        minecraft "net.minecraft:minecraft:$rootProject.minecraft_version"

        mappings loom.layered {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${minecraft_version}:${parchment_version}@zip")
        }

        implementation 'com.github.luben:zstd-jni:1.5.7-6'
        minecraftRuntimeLibraries 'com.github.luben:zstd-jni:1.5.7-6'

        // Java-only Jolt library
        implementation "com.github.stephengold:jolt-jni-Linux64:${jolt_jni_version}"
        minecraftRuntimeLibraries "com.github.stephengold:jolt-jni-Linux64:${jolt_jni_version}"

        // Native libraries classifier variable
        def nativeClassifier = "ReleaseSp" // classifier used for all native platforms

        // List of native platforms
        def nativePlatforms = [
                'Windows64',
                'Linux64',
                'Linux_ARM64',
                'MacOSX64',
                'MacOSX_ARM64'
        ]

        // Loop through each platform and add the native library
        nativePlatforms.each { os ->
            implementation "com.github.stephengold:jolt-jni-${os}:${jolt_jni_version}:${nativeClassifier}"
            minecraftRuntimeLibraries "com.github.stephengold:jolt-jni-${os}:${jolt_jni_version}:${nativeClassifier}"
        }
    }

    java {
        withSourcesJar()

        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.release = 17
    }

    tasks.withType(GenerateModuleMetadata).configureEach {
        enabled = false
    }

    publishing {
        repositories {
            maven {
                name = "Cloudsmith"
                url = "https://maven.cloudsmith.io/imx-dev/velthoric/"
                credentials {
                    username = rootProject.ext.cloudsmith_user
                    password = rootProject.ext.cloudsmith_key
                }
            }
        }
    }
}

/**
 * Master Release Task: publishVelthoric
 *
 * Orchestrates the full deployment pipeline.
 * Validates that necessary credentials are loaded before execution.
 */
tasks.register("publishVelthoric") {
    group = "publishing"
    description = "Validates credentials and publishes the mod to GitHub, CurseForge, and Modrinth."

    dependsOn "githubRelease"

    doFirst {
        def missingVars = []
        if (!rootProject.ext.github_token) missingVars.add("github_token")
        if (!rootProject.ext.modrinth_token) missingVars.add("modrinth_token")
        if (!rootProject.ext.curseforge_token) missingVars.add("curseforge_token")

        if (!missingVars.isEmpty()) {
            throw new GradleException("Release failed. Missing keys in 'credentials.properties': ${missingVars.join(', ')}")
        }

        logger.lifecycle("Credentials validated. Starting release for version ${rootProject.mod_version}...")
    }

    doLast {
        logger.lifecycle("Velthoric release completed successfully!")
    }
}

subprojects {
    afterEvaluate {
        def sub = project

        if (sub.plugins.hasPlugin("me.modmuss50.mod-publish-plugin")) {
            rootProject.tasks.named("publishVelthoric").configure {
                dependsOn(sub.tasks.named("publishMods"))
            }
        }
    }
}

task generateJoltDoc {

    def joltModule = configurations.detachedConfiguration(
            dependencies.create("com.github.stephengold:jolt-jni-Linux64:${jolt_jni_version}")
    ).singleFile

    def outputFile = file("$buildDir/docs/jolt.txt")

    inputs.file(joltModule)
    outputs.file(outputFile)

    doLast {
        println "=== JoltDoc Generation Started ==="

        if (!joltModule.exists()) {
            throw new FileNotFoundException("Input JAR not found: ${joltModule.absolutePath}")
        }

        println "Analyzing JAR: ${joltModule.name}"
        println "Writing output to: ${outputFile.absolutePath}"

        outputFile.parentFile.mkdirs()
        outputFile.text = ''

        def zipFile = new java.util.zip.ZipFile(joltModule)
        def classEntries = zipFile.entries().findAll { entry ->
            !entry.isDirectory() && entry.name.endsWith('.class')
        }

        println "Found ${classEntries.size()} class files."

        classEntries.eachWithIndex { entry, idx ->
            def className = entry.name.replace('/', '.').replaceAll('\\.class$', '')
            println "[${idx + 1}/${classEntries.size()}] Processing class: ${className}"

            def commandOutput = new ByteArrayOutputStream()

            project.exec {
                executable = 'javap'
                args '-p', '-classpath', joltModule.absolutePath, className
                standardOutput = commandOutput
                ignoreExitValue = true
            }

            outputFile.append("${className.substring(className.lastIndexOf('.') + 1)}.class:\n")

            def javapResult = commandOutput.toString()
            def methodLines = javapResult.lines()
                    .findAll { it.contains('(') && it.contains(')') && !it.contains('{') && !it.contains('Compiled from') }
                    .findAll { it.trim().startsWith('public') || it.trim().startsWith('protected') }

            println "  Found ${methodLines.size()} methods in ${className}."

            methodLines.each { line ->
                String cleanedLine = line.trim()
                        .replaceAll('public |protected |static |final |synchronized |native ', '')

                if (line.trim().startsWith('protected')) {
                    cleanedLine = "protected ${cleanedLine}"
                }

                outputFile.append("  ${cleanedLine}\n")
                println "    Logged method: ${cleanedLine}"
            }

            outputFile.append("\n")
        }

        zipFile.close()
        println "=== JoltDoc Generation Finished ==="
    }
}